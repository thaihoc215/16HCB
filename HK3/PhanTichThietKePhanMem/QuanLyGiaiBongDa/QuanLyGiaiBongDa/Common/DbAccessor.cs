/*
 * 1642021 - Ha Nguyen Thai Hoc
 * 17/03/2017 - PasswordHelper
 */
using AutoMapper;
using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;
using Microsoft.Practices.EnterpriseLibrary.Data;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QuanLyGiaiBongDa.Common
{

    public abstract class DbAccessor : IDisposable
    {

        private const string ParameterNamePrefix = "@";

        protected IDbConnection Connection;

        private IList<IDataReader> _dataReaders;

        private IList<IDataReader> DataReaders
        {
            get
            {
                if (_dataReaders == null) _dataReaders = new List<IDataReader>();
                return _dataReaders;
            }
        }

        protected DbAccessor()
        {
            Initialize(() => { return DatabaseFactory.CreateDatabase(); });
        }

        protected DbAccessor(string databaseName)
        {
            Initialize(() => { return DatabaseFactory.CreateDatabase(databaseName); });
        }

        private void Initialize(Func<Database> createDatabase)
        {
            try
            {
                //SystemConfigurationSource systemSource = new SystemConfigurationSource();
                //DatabaseProviderFactory factory2 = new DatabaseProviderFactory(systemSource);
                //Database db2 = factory2.Create("QUANLYGIAIBONGDA");
                //DatabaseProviderFactory factory = new DatabaseProviderFactory();
                //factory.Create(@"Data Source=HOCHNT\HOCHNT;Initial Catalog=QUANLYGIAIBONGDA;Integrated Security=True");
                Connection = createDatabase().CreateConnection();
                Connection.Open();
            }
            catch (Exception)
            {
                CloseConnection();
                throw;
            }
        }

        public List<T> Query<T>(string commandText, params object[] values)
        {
            return Query<T>((dataReader) =>
            {
                Mapper.CreateMap<IDataReader, T>();
                return Mapper.Map<IDataReader, List<T>>(dataReader);
            }
            , commandText, values);
        }


        public List<T> Query<T>(Converter<IDataReader, List<T>> converter, string commandText, params object[] values)
        {
            IDataReader dataReader = Query(commandText, values);
            try
            {
                return converter(dataReader);
            }
            catch (Exception)
            {
                HandleException();
                throw;
            }
        }


        public IDataReader Query(string commandText, params object[] values)
        {
            return ExecuteCommand<IDataReader>((command) =>
            {
                IDataReader result = command.ExecuteReader();
                DataReaders.Add(result);
                return result;
            }
            , commandText, values);
        }

        /// <summary>
        // / Get single item value. Return the value of the first column of the first row of the SQL result.
        /// </ summary>
        /// <typeparam name = "T"> Item value type </ typeparam>
        /// <param name = "commandText"> SQL statement (parameter name should be [@ 1, @ 2, ...]) </ param>
        /// <param name = "values"> Parameter value </ param>
        /// <returns> item value </ returns>
        public T Scalar<T>(string commandText, params object[] values)
        {
            return ExecuteCommand<T>((command) => { return (T)command.ExecuteScalar(); }, commandText, values);
        }

        /// <summary>
        /// Data update.
        /// </ summary>
        /// <param name = "commandText"> SQL statement (parameter name should be [@ 1, @ 2, ...]) </ param>
        /// <param name = "values"> Parameter value </ param>
        /// <returns> Number of updated lines </ returns>
        public int NonQuery(string commandText, params object[] values)
        {
            return ExecuteCommand<int>((command) => { return command.ExecuteNonQuery(); }, commandText, values);
        }

        /// <summary>
        /// Release the resource and commit if this object is [TransactionDbAccessor].
        /// </ summary>
        /// <remarks>
        /// We also release the data reader generated by query execution.
        /// </ remarks>
        public void Dispose()
        {
            try
            {
                CloseDataReaders();
                DoSomethingAtDispose();
            }
            finally
            {
                CloseConnection();
            }
        }

        private TResult ExecuteCommand<TResult>(Func<IDbCommand, TResult> execution, string commandText, params object[] values)
        {
            using (IDbCommand command = CreateCommand(commandText, values))
            {
                try
                {
                    return execution(command);
                }
                catch (Exception)
                {
                    HandleException();
                    throw;
                }
            }
        }

        protected IDbCommand CreateCommand(string commandText, params object[] values)
        {
            //LogUtil.GetSqlTraceLogger.Debug(GetSqlLogMessage(commandText, values));

            IDbCommand result = null;
            try
            {
                result = Connection.CreateCommand();
                SetSomething(result);
                result.CommandText = commandText;
                SetParameters(result, values);
                return result;
            }
            catch (Exception)
            {
                if (result != null) Quietly(() => { result.Dispose(); });
                HandleException();
                throw;
            }
        }

        private static void SetParameters(IDbCommand command, params object[] values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                IDbDataParameter parameter = command.CreateParameter();
                parameter.ParameterName = ParameterNamePrefix + (i + 1);
                parameter.Value = values[i];
                command.Parameters.Add(parameter);
            }
        }

        protected void CloseDataReaders()
        {
            if (_dataReaders == null || _dataReaders.Count == 0) return;
            foreach (IDataReader dataReader in DataReaders)
            {
                if (dataReader == null || dataReader.IsClosed) continue;
                Quietly(() => { dataReader.Close(); });
            }
            _dataReaders.Clear();
        }

        protected void CloseConnection()
        {
            if (Connection == null || Connection.State == ConnectionState.Closed) return;
            Quietly(() => { Connection.Close(); });
        }

        protected static void Quietly(Action action)
        {
            try
            {
                action();
            }
            catch (Exception) { }
        }

        protected virtual void SetSomething(IDbCommand command) { }

        protected virtual void HandleException() { }

        protected virtual void DoSomethingAtDispose() { }

        private static string GetSqlLogMessage(String command, object[] parameters)
        {
            string[] strParams = Array.ConvertAll<object, string>(parameters,
                new Converter<object, string>(s => s.ToString()));

            StringBuilder msg = new StringBuilder();
            msg.Append(" Query: ");
            msg.Append(command);
            msg.Append(" Parameters: ");
            msg.Append("[");
            if (strParams != null)
            {
                msg.Append(string.Join(", ", strParams));
            }
            msg.Append("]");
            return msg.ToString();
        }
    }

    /// <summary>
    /// DB access object in autocommit mode. It hides generation / release of various resources and eliminates the description of exception handling.
    /// </ summary>
    /// <example>
    /// [Example of usage code]
    /// <code>
    /// using (AutoCommitDbAccessor db = new AutoCommitDbAccessor ())
    /// {
    ///     List <customer> customers = db.Query & lt; Customer & gt; (& quot; SELECT * FROM customer & quot;);
    ///     // (short)
    ///     int count = db.NonQuery (& quot; UPDATE customer SET name = @ 1 WHERE code = @ 2 & quot ;, name, code);
    ///     // (short)
    ///}
    /// </ code>
    /// </ example>
    /// <remarks>
    /// Since we are releasing various resources with /// Dispose method, we recommend [use with using statement (= implicit Dispose method call)].
    /// If you do not use the /// using statement, do [Explicit Dispose method call].
    /// </ remarks>
    public class AutoCommitDbAccessor : DbAccessor
    {
        /// <summary>
        /// Constructor.
        /// </ summary>
        /// <remarks>
        /// Adopt the default database specified in the application configuration file (App.config).
        /// </ remarks>
        public AutoCommitDbAccessor() : base() { }

        /// <summary>
        /// Constructor.
        /// </ summary>
        /// <param name = "databaseName"> Database name (name of [connectionStrings] in application configuration file (App.config)) </ param>
        public AutoCommitDbAccessor(string databaseName) : base(databaseName) { }
    }

    /// <summary>
    // / DB access object for transaction processing. We hide generation / release of various resources and eliminate the description of exception handling and commit / rollback.
    /// </ summary>
    /// <example>
    /// [Example of usage code]
    /// <code>
    /// using (TransactionDbAccessor db = new TransactionDbAccessor ())
    /// {
    /// List <customer> customers = db.Query & lt; Customer & gt; (& quot; SELECT * FROM customer & quot;);
    /// / / (short)
    /// try
    /// {
    /// db.NonQuery (& quot; INSERT INTO customer (code, name) VALUES (@ 1, @ 2) & quot ;, code, name);
    ///}
    /// catch (Exception)
    /// {
    /// db.NonQuery (& quot; UPDATE customer SET name = @ 1 WHERE code = @ 2 & quot ;, name, code);
    ///}
    /// // (short)
    ///}
    /// </code>
    /// </example>
    /// <remarks>
    /// Dispose method. We recommend [use with using statement (= implicit Dispose method call)] because we are committing and releasing various resources with
    /// using statement If you do not use the [Explicit Dispose method call].
    /// Note that rollback is done internally when an exception occurs.
    /// </remarks>
    public class TransactionDbAccessor : DbAccessor
    {
        private IDbTransaction Transaction;

        private bool IsCompletedTransaction = false;

        /// <summary>
        /// Constructor.
        /// </ summary>
        /// <remarks>
        /// Adopt the default database specified in the application configuration file (App.config).
        /// </remarks>
        public TransactionDbAccessor() : base() { Initialize(); }

        /// <summary>
        /// Constructor.
        /// </ summary>
        /// <param name = "databaseName"> Database name (name of [connectionStrings] in application configuration file (App.config)) </ param>
        public TransactionDbAccessor(string databaseName) : base(databaseName) { Initialize(); }

        private void Initialize()
        {
            try
            {
                Transaction = Connection.BeginTransaction(IsolationLevel.ReadCommitted);
            }
            catch (Exception)
            {
                CloseConnection();
                throw;
            }
        }

        /// <summary>
        /// Data update. It does not roll back even if an exception occurs in SQL execution. It assumes use in the case of catch / handling such as [key overlap in INSERT] etc.
        /// </ summary>
        /// <param name = "commandText"> SQL statement (parameter name should be [@ 1, @ 2, ...]) </ param>
        /// <param name = "values"> Parameter value </ param>
        /// <returns> Number of updated lines </ returns>
        public int NonQueryDoesNotRollbackWhenExceptionThrown(string commandText, params object[] values)
        {
            using (IDbCommand command = CreateCommand(commandText, values))
            {
                return command.ExecuteNonQuery();
            }
        }

        protected override void SetSomething(IDbCommand command)
        {
            command.Transaction = Transaction;
        }

        protected override void HandleException()
        {
            CloseDataReaders();
            Quietly(() => { Transaction.Rollback(); });
            IsCompletedTransaction = true;
        }

        protected override void DoSomethingAtDispose()
        {
            if (IsCompletedTransaction) return;
            try
            {
                Transaction.Commit();
            }
            catch (Exception)
            {
                Quietly(() => { Transaction.Rollback(); });
                throw;
            }
            finally
            {
                IsCompletedTransaction = true;
            }
        }

        /// <summary>
        /// roll back. If you also perform a process other than "Process with this object" in the using statement and an exception can occur in that process,
        /// Call this method on exception catch.
        /// </ summary>
        /// <example>
        /// [Example of usage code]
        /// <code>
        /// using (TransactionDbAccessor db = new TransactionDbAccessor ())
        /// {
        /// try
        /// {
        /// DB access, and other processing.
        ///}
        /// catch (Exception)
        /// {
        /// db.Rollback ();
        ///}
        ///}
        /// </code>
        /// </example>
        public void Rollback()
        {
            HandleException();
        }
    }
}
